import axios from "axios";
import ytdl from "ytdl-core";
import { createFFmpeg } from "@ffmpeg/ffmpeg";
import { cache } from "../utils/cache";
import { youtubeTranscriptApi } from "youtube-transcript";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";

class YouTubeService {
  constructor() {
    this.apiKey = process.env.YOUTUBE_API_KEY;
    this.ffmpeg = createFFmpeg({ log: false });
    this.cache = cache;

    if (!this.apiKey) {
      throw new Error("YouTube API key not found in environment variables");
    }

    this.apiClient = axios.create({
      baseURL: "https://www.googleapis.com/youtube/v3",
      params: {
        key: this.apiKey,
      },
    });
  }

  async getVideoInfo(videoId) {
    try {
      const cacheKey = `video_info:${videoId}`;
      const cachedInfo = await this.cache.get(cacheKey);
      if (cachedInfo) return cachedInfo;

      const response = await this.apiClient.get("/videos", {
        params: {
          part: "snippet,contentDetails,statistics",
          id: videoId,
        },
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new ApiError("Video not found", 404);
      }

      const videoData = response.data.items[0];
      const { snippet, contentDetails, statistics } = videoData;

      const info = {
        id: videoId,
        title: snippet.title,
        description: snippet.description,
        author: snippet.channelTitle,
        thumbnail:
          snippet.thumbnails.maxres?.url || snippet.thumbnails.high.url,
        publishDate: new Date(snippet.publishedAt),
        duration: this.formatDuration(contentDetails.duration),
        views: parseInt(statistics.viewCount, 10),
        likes: parseInt(statistics.likeCount, 10),
      };

      await this.cache.set(cacheKey, info, 3600); // Cache for 1 hour
      return info;
    } catch (error) {
      logger.error("Error fetching video info:", error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(
        error.response?.data?.error?.message || "Failed to fetch video info",
        error.response?.status || 500
      );
    }
  }

  async getTranscript(videoId, languageCode = "en") {
    try {
      const cacheKey = `transcript:${videoId}:${languageCode}`;
      const cachedTranscript = await this.cache.get(cacheKey);
      if (cachedTranscript) return cachedTranscript;

      const transcript = await youtubeTranscriptApi.fetchTranscript(videoId, {
        lang: languageCode,
      });

      if (!transcript || transcript.length === 0) {
        throw new ApiError("No transcript available", 404);
      }

      const formattedTranscript = {
        text: transcript.map((item) => item.text).join(" "),
        language: languageCode,
        isAutoGenerated: transcript[0].isAutoGenerated || false,
        segments: transcript.map((item) => ({
          text: item.text,
          start: item.start,
          duration: item.duration,
        })),
      };

      await this.cache.set(cacheKey, formattedTranscript, 86400); // Cache for 24 hours
      return formattedTranscript;
    } catch (error) {
      logger.error("Error fetching transcript:", error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(
        error.message || "Failed to fetch transcript",
        error.status || 500
      );
    }
  }

  async checkTranscriptAvailability(videoId) {
    try {
      const cacheKey = `transcript_available:${videoId}`;
      const cachedAvailability = await this.cache.get(cacheKey);
      if (cachedAvailability !== undefined) return cachedAvailability;

      const transcript = await youtubeTranscriptApi.fetchTranscript(videoId, {
        lang: "en",
      });

      const hasTranscript = transcript && transcript.length > 0;
      const stream = ytdl(url, {
        quality: "highestaudio",
        filter: "audioonly",
      });

      const buffer = await this.streamToBuffer(stream);
      await this.ffmpeg.write("input.webm", buffer);

      await this.ffmpeg.run("-i", "input.webm", "-q:a", "0", outputPath);

      return outputPath;
    } catch (error) {
      throw new Error(`Failed to download audio: ${error.message}`);
    }
  }

  extractVideoId(url) {
    try {
      const videoId = ytdl.getVideoID(url);
      return videoId;
    } catch (error) {
      throw new Error("Invalid YouTube URL");
    }
  }

  parseTranscript(rawTranscript) {
    // Implement transcript parsing logic
    // Convert raw transcript to structured format
    return {
      segments: [],
      text: "",
    };
  }

  async streamToBuffer(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
      stream.on("data", (chunk) => chunks.push(chunk));
      stream.on("end", () => resolve(Buffer.concat(chunks)));
      stream.on("error", reject);
    });
  }

  validateUrl(url) {
    return ytdl.validateURL(url);
  }
}

export default new YouTubeService();
